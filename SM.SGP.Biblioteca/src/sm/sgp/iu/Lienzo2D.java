package sm.sgp.iu;

import sm.sgp.graficos.MiRectangulo;
import sm.sgp.graficos.MiElipse;
import sm.sgp.graficos.MiLinea;
import java.awt.BasicStroke;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.*;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.ArrayList;
import java.util.EventListener;
import java.util.EventObject;
import sm.sgp.graficos.*;

/**
 * Clase que representa un lienzo 2D donde se pueden dibujar diferentes figuras.
 */
public class Lienzo2D extends javax.swing.JPanel {

    public enum Herramienta {
        LINEA,
        RECTANGULO,
        ELIPSE,
        FANTASMA
    }

    private Color color = Color.black;
    private Herramienta herramienta = Herramienta.LINEA;
    private boolean relleno = false;
    private boolean edicion = false;

    private Point2D posicionPressed = new Point(0, 0);
    private Point2D posicionDragged = new Point(0, 0);

    private AbstractShape figura = new MiLinea();
    private AbstractShape figuraSeleccionada = null;
    private MarcadorSeleccion marcadorSeleccion = null;
    private final List<AbstractShape> vAbstractShape = new ArrayList<>();

    private Stroke grosor = new BasicStroke();

    private boolean transparenciaActiva = false;
    private boolean alisadoActivo = false;

    private BufferedImage imgFuente = null;

    private final Rectangle areaDibujo;
    private static final int AREA_SIZE = 700;

    ArrayList<LienzoListener> lienzoEventListeners = new ArrayList();

    /**
     * Constructor de la clase Lienzo2D.
     */
    public Lienzo2D() {
        initComponents();
        areaDibujo = new Rectangle(0, 0, AREA_SIZE, AREA_SIZE);
    }

    /**
     * Método que se encarga de pintar el lienzo y las figuras en él.
     *
     * @param g El objeto Graphics utilizado para pintar.
     */
    @Override
    public void paint(Graphics g) {
        super.paint(g);

        Graphics2D g2d = (Graphics2D) g;

        g2d.setColor(Color.WHITE);
        g2d.fillRect(0, 0, getWidth(), getHeight());

        // Dibujar el rectángulo con bordes discontinuos
        g2d.setColor(Color.BLACK);
        g2d.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10, new float[]{5, 5}, 0));
        g2d.drawRect(areaDibujo.x - 1, areaDibujo.y - 1, areaDibujo.width + 1, areaDibujo.height + 1);

        if (imgFuente != null) {
            g2d.drawImage(imgFuente, areaDibujo.x, areaDibujo.y, areaDibujo.width, areaDibujo.height, this);
        }

        for (AbstractShape s : vAbstractShape) {
            s.draw(g2d);
        }

        if (edicion && marcadorSeleccion != null) {
            marcadorSeleccion.draw(g2d);
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setPreferredSize(new java.awt.Dimension(800, 600));
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Verifica si la funcionalidad de mover está activa.
     *
     * @return true si la funcionalidad de mover está activa, false de lo
     * contrario.
     */
    public boolean isMoverActivo() {
        return edicion;
    }

    /**
     * Establece el estado de la funcionalidad de mover.
     *
     * @param mover true para activar la funcionalidad de mover, false para
     * desactivarla.
     */
    public void setMoverActivo(boolean mover) {
        this.edicion = mover;
    }

    /**
     * Obtiene el color actual del lienzo.
     *
     * @return El color actual del lienzo.
     */
    public Color getColor() {
        return color;
    }

    /**
     * Establece el color del lienzo.
     *
     * @param color El color a establecer.
     */
    public void setColor(Color color) {
        this.color = color;
    }

    /**
     * Verifica si la funcionalidad de relleno está activa.
     *
     * @return true si la funcionalidad de relleno está activa, false de lo
     * contrario.
     */
    public boolean isRellenoActivo() {
        return relleno;
    }

    /**
     * Establece el estado de la funcionalidad de relleno.
     *
     * @param relleno true para activar la funcionalidad de relleno, false para
     * desactivarla.
     */
    public void setRellenoActivo(boolean relleno) {
        this.relleno = relleno;
    }

    /**
     * Obtiene la herramienta de dibujo actual.
     *
     * @return La herramienta de dibujo actual.
     */
    public Herramienta getHerramienta() {
        return herramienta;
    }

    /**
     * Establece la herramienta de dibujo.
     *
     * @param herramienta La herramienta de dibujo a establecer.
     */
    public void setHerramienta(Herramienta herramienta) {
        this.herramienta = herramienta;
    }

    /**
     * Borra todas las figuras del lienzo.
     */
    public void borrar() {
        this.vAbstractShape.clear();
        this.repaint();
    }

    /**
     * Establece el grosor del trazo.
     *
     * @param grosor El grosor del trazo a establecer.
     */
    public void setGrosor(int grosor) {
        this.grosor = new BasicStroke(grosor);
        this.repaint();
    }

    /**
     * Obtiene el grosor del trazo actual.
     *
     * @return El grosor del trazo actual.
     */
    public int getGrosor() {
        return (int) ((BasicStroke) grosor).getLineWidth();
    }

    /**
     * Establece el estado de la transparencia.
     *
     * @param t true para activar la transparencia, false para desactivarla.
     */
    public void setTransparenciaActiva(boolean t) {
        this.transparenciaActiva = t;
    }

    /**
     * Verifica si la transparencia está activa.
     *
     * @return true si la transparencia está activa, false de lo contrario.
     */
    public boolean isTransparenciaActiva() {
        return transparenciaActiva;
    }

    /**
     * Establece el estado del alisado.
     *
     * @param a true para activar el alisado, false para desactivarlo.
     */
    public void setAlisadoActivo(boolean a) {
        this.alisadoActivo = a;
    }

    /**
     * Verifica si el alisado está activo.
     *
     * @return true si el alisado está activo, false de lo contrario.
     */
    public boolean isAlisadoActivo() {
        return alisadoActivo;
    }

    public boolean isEdicionActivo() {
        return edicion;
    }

    public void setEdicionActivo(boolean edicion) {
        this.edicion = edicion;
    }

    public AbstractShape getFiguraSeleccionada() {
        return figuraSeleccionada;
    }

    public static int getAREA_SIZE() {
        return AREA_SIZE;
    }

    public void setImage(BufferedImage img) {
        this.imgFuente = img;
        if (img != null) {
            // Establecer el tamaño preferido del lienzo con un margen de 200 píxeles
            setPreferredSize(new Dimension(img.getWidth() + 200, img.getHeight() + 200));

            // Actualizar el tamaño y la posición del área de dibujo
            areaDibujo.setBounds(0, 0, img.getWidth(), img.getHeight());
        } else {
            // Si no hay imagen, establecer el tamaño preferido y el área de dibujo a valores predeterminados
            setPreferredSize(new Dimension(AREA_SIZE + 200, AREA_SIZE + 200));
            areaDibujo.setBounds(0, 0, AREA_SIZE, AREA_SIZE);
        }
        repaint(); // Volver a pintar el lienzo con el nuevo tamaño
    }

    public BufferedImage getImage() {
        return imgFuente;
    }

    public BufferedImage getPaintedImage() {
        BufferedImage imgout = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2dImagen = imgout.createGraphics();
        if (imgFuente != null) {
            g2dImagen.drawImage(imgFuente, 0, 0, this);
        }
        for (AbstractShape s : vAbstractShape) {
            s.draw(g2dImagen);
        }
        g2dImagen.dispose();

        return imgout;
    }

    private BufferedImage clonarImagen(BufferedImage img) {
        BufferedImage copia = new BufferedImage(img.getWidth(), img.getHeight(), BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = copia.createGraphics();
        g2d.drawImage(img, 0, 0, null);
        g2d.dispose();
        return copia;
    }

    /**
     * Método que busca la figura seleccionada en una posición dada.
     *
     * @param p La posición donde se busca la figura seleccionada.
     * @return La figura seleccionada, o null si no se encontró ninguna.
     */
    private AbstractShape figuraSeleccionada(Point2D p) {
        for (int i = vAbstractShape.size() - 1; i >= 0; i--) {
            AbstractShape s = vAbstractShape.get(i);
            if (s.contains(p)) {
                figuraSeleccionada = s;
                marcadorSeleccion = new MarcadorSeleccion(s.getLocation());
                notifyShapeSelectedEvent(new LienzoEvent(this, s));
                return s;
            }
        }
        figuraSeleccionada = null;
        marcadorSeleccion = null;
        return null;
    }

    public void updateFiguraSeleccionada() {
        if (figuraSeleccionada != null) {
            figuraSeleccionada.setColor(color);
            figuraSeleccionada.setGrosor(grosor);
            figuraSeleccionada.setTransparenciaActiva(transparenciaActiva);
            figuraSeleccionada.setAlisadoActivo(alisadoActivo);
            if (figuraSeleccionada instanceof AbstractShapeFilled abstractShapeFilled) {
                abstractShapeFilled.setRelleno(relleno);
            }
            this.repaint();
        }
    }

    public void volcarFiguraSeleccionada() {
        if (figuraSeleccionada != null) {
            Graphics2D g2d = imgFuente.createGraphics();
            figuraSeleccionada.draw(g2d);
            g2d.dispose();
            vAbstractShape.remove(figuraSeleccionada);
            figuraSeleccionada = null;
            marcadorSeleccion = null;
            this.repaint();
        }
    }

    public class LienzoEvent extends EventObject {

        private final AbstractShape forma;

        public LienzoEvent(Object source, AbstractShape forma) {
            super(source);
            this.forma = forma;
        }

        public AbstractShape getForma() {
            return forma;
        }
    }

    public interface LienzoListener extends EventListener {

        public void shapeAdded(LienzoEvent evt);

        public void shapeSelected(LienzoEvent evt);
    }

    public void addLienzoListener(LienzoListener listener) {
        if (listener != null) {
            lienzoEventListeners.add(listener);
        }
    }

    private void notifyShapeAddedEvent(LienzoEvent evt) {
        if (!lienzoEventListeners.isEmpty()) {
            for (LienzoListener listener : lienzoEventListeners) {
                listener.shapeAdded(evt);
            }
        }
    }

    private void notifyShapeSelectedEvent(LienzoEvent evt) {
        if (!lienzoEventListeners.isEmpty()) {
            for (LienzoListener listener : lienzoEventListeners) {
                listener.shapeSelected(evt);
            }
        }
    }

    /**
     * Método que se ejecuta cuando se presiona el botón del mouse en el lienzo.
     *
     * @param evt El evento del mouse.
     */
    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        if (areaDibujo.contains(evt.getPoint())) {
            this.posicionPressed = evt.getPoint();

            if (edicion) {
                figura = figuraSeleccionada(evt.getPoint());
            } else {
                AbstractShape figuraAux = null;
                switch (herramienta) {
                    case LINEA:
                        figuraAux = new MiLinea(posicionPressed, posicionPressed);
                        break;
                    case RECTANGULO:
                        figuraAux = new MiRectangulo(posicionPressed, posicionPressed);
                        break;
                    case ELIPSE:
                        figuraAux = new MiElipse(posicionPressed, posicionPressed);
                        break;
                    case FANTASMA:
                        figuraAux = new MiFantasma(posicionPressed);
                        break;
                }

                if (figuraAux != null) {
                    figuraAux.setColor(color);
                    figuraAux.setGrosor(grosor);
                    figuraAux.setTransparenciaActiva(transparenciaActiva);
                    figuraAux.setAlisadoActivo(alisadoActivo);
                    if (figuraAux instanceof AbstractShapeFilled abstractShapeFilled) {
                        abstractShapeFilled.setRelleno(relleno);
                    }
                    this.figura = figuraAux;
                    this.vAbstractShape.add(figura);
                    notifyShapeAddedEvent(new LienzoEvent(this, figura));
                }
            }
        }
    }//GEN-LAST:event_formMousePressed

    /**
     * Método que se ejecuta cuando se arrastra el mouse en el lienzo.
     *
     * @param evt El evento del mouse.
     */
    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        this.posicionDragged = evt.getPoint();

        if (figura != null) {

            if (edicion) {
                switch (figura) {
                    case MiLinea miLinea ->
                        miLinea.setLocation(posicionDragged);
                    case MiRectangulo miRectangulo ->
                        miRectangulo.setLocation(posicionDragged);
                    case MiElipse miElipse ->
                        miElipse.setLocation(posicionDragged);
                    case MiFantasma miFantasma ->
                        miFantasma.setLocation(posicionDragged);
                    default -> {
                    }
                }
                if (marcadorSeleccion != null) {
                    marcadorSeleccion.setLocation(figura.getLocation());
                }
            } else {
                switch (herramienta) {
                    case LINEA:
                        ((MiLinea) figura).setLine(posicionPressed, posicionDragged);
                        break;
                    case RECTANGULO:
                        ((MiRectangulo) figura).setFrameFromDiagonal(posicionPressed, posicionDragged);
                        break;
                    case ELIPSE:
                        ((MiElipse) figura).setFrameFromDiagonal(posicionPressed, posicionDragged);
                        break;
                }
            }
        }
        this.repaint();
    }//GEN-LAST:event_formMouseDragged

    /**
     * Método que se ejecuta cuando se suelta el botón del mouse en el lienzo.
     *
     * @param evt El evento del mouse.
     */
    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        if (areaDibujo.contains(evt.getPoint())) {
            this.figura = null;
            this.repaint();
        }
    }//GEN-LAST:event_formMouseReleased

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
