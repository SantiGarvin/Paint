package sm.sgp.iu;

import sm.sgp.graficos.MiRectangulo;
import sm.sgp.graficos.MiElipse;
import sm.sgp.graficos.MiLinea;
import java.awt.BasicStroke;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.geom.*;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.Stroke;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.ArrayList;
import sm.sgp.graficos.*;

/**
 * Clase que representa un lienzo 2D donde se pueden dibujar diferentes figuras.
 */
public class Lienzo2D extends javax.swing.JPanel {

    public enum Herramienta {
        LINEA,
        RECTANGULO,
        ELIPSE,
        FANTASMA
    }

    private Color color = Color.black;
    private Herramienta herramienta = Herramienta.LINEA;
    private boolean relleno = false;
    private boolean edicion = false;

    private Point2D posicionPressed = new Point(0, 0);
    private Point2D posicionDragged = new Point(0, 0);

    private Shape figura = new Line2D.Float();
    private Shape figuraSeleccionada = null;
    private MarcadorSeleccion marcadorSeleccion = null;
    private List<Shape> vShape = new ArrayList<>();

    private Stroke grosor = new BasicStroke();

    private boolean transparenciaActiva = false;
    private boolean alisadoActivo = false;

    private BufferedImage img = null;

    /**
     * Constructor de la clase Lienzo2D.
     */
    public Lienzo2D() {
        initComponents();
    }

    /**
     * Método que se encarga de pintar el lienzo y las figuras en él.
     *
     * @param g El objeto Graphics utilizado para pintar.
     */
    @Override
    public void paint(Graphics g) {
        super.paint(g);

        g.setColor(Color.white);
        g.fillRect(0, 0, this.getWidth(), this.getHeight());

        Graphics2D g2d = (Graphics2D) g;

        if (img != null) {
            g2d.drawImage(img, 0, 0, this);
        }

        for (Shape s : vShape) {
            ((AbstractShape) s).draw(g2d);
        }

        if (edicion && marcadorSeleccion != null) {
            marcadorSeleccion.draw(g2d);
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    public void setImage(BufferedImage img) {
        this.img = img;
        if (img != null) {
            setPreferredSize(new Dimension(img.getWidth(), img.getHeight()));
        }
    }

    public BufferedImage getImage() {
        return img;
    }

    public BufferedImage getPaintedImage() {
        BufferedImage imgout = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2dImagen = imgout.createGraphics();
        if (img != null) {
            g2dImagen.drawImage(img, 0, 0, this);
        }
        for (Shape s : vShape) {
            ((AbstractShape) s).draw(g2dImagen);
        }
        g2dImagen.dispose();
        return imgout;
    }

    /**
     * Verifica si la funcionalidad de mover está activa.
     *
     * @return true si la funcionalidad de mover está activa, false de lo
     * contrario.
     */
    public boolean isMoverActivo() {
        return edicion;
    }

    /**
     * Establece el estado de la funcionalidad de mover.
     *
     * @param mover true para activar la funcionalidad de mover, false para
     * desactivarla.
     */
    public void setMoverActivo(boolean mover) {
        this.edicion = mover;
    }

    /**
     * Obtiene el color actual del lienzo.
     *
     * @return El color actual del lienzo.
     */
    public Color getColor() {
        return color;
    }

    /**
     * Establece el color del lienzo.
     *
     * @param color El color a establecer.
     */
    public void setColor(Color color) {
        this.color = color;
    }

    /**
     * Verifica si la funcionalidad de relleno está activa.
     *
     * @return true si la funcionalidad de relleno está activa, false de lo
     * contrario.
     */
    public boolean isRellenoActivo() {
        return relleno;
    }

    /**
     * Establece el estado de la funcionalidad de relleno.
     *
     * @param relleno true para activar la funcionalidad de relleno, false para
     * desactivarla.
     */
    public void setRellenoActivo(boolean relleno) {
        this.relleno = relleno;
    }

    /**
     * Obtiene la herramienta de dibujo actual.
     *
     * @return La herramienta de dibujo actual.
     */
    public Herramienta getHerramienta() {
        return herramienta;
    }

    /**
     * Establece la herramienta de dibujo.
     *
     * @param herramienta La herramienta de dibujo a establecer.
     */
    public void setHerramienta(Herramienta herramienta) {
        this.herramienta = herramienta;
    }

    /**
     * Borra todas las figuras del lienzo.
     */
    public void borrar() {
        this.vShape.clear();
        this.repaint();
    }

    /**
     * Establece el grosor del trazo.
     *
     * @param grosor El grosor del trazo a establecer.
     */
    public void setGrosor(int grosor) {
        this.grosor = new BasicStroke(grosor);
        this.repaint();
    }

    /**
     * Obtiene el grosor del trazo actual.
     *
     * @return El grosor del trazo actual.
     */
    public Stroke getGrosor() {
        return grosor;
    }

    /**
     * Establece el estado de la transparencia.
     *
     * @param t true para activar la transparencia, false para desactivarla.
     */
    public void setTransparenciaActiva(boolean t) {
        this.transparenciaActiva = t;
    }

    /**
     * Verifica si la transparencia está activa.
     *
     * @return true si la transparencia está activa, false de lo contrario.
     */
    public boolean isTransparenciaActiva() {
        return transparenciaActiva;
    }

    /**
     * Establece el estado del alisado.
     *
     * @param a true para activar el alisado, false para desactivarlo.
     */
    public void setAlisadoActivo(boolean a) {
        this.alisadoActivo = a;
    }

    /**
     * Verifica si el alisado está activo.
     *
     * @return true si el alisado está activo, false de lo contrario.
     */
    public boolean isAlisadoActivo() {
        return alisadoActivo;
    }

    public Shape getFiguraSeleccionada() {
        return figuraSeleccionada;
    }

    /**
     * Método que busca la figura seleccionada en una posición dada.
     *
     * @param p La posición donde se busca la figura seleccionada.
     * @return La figura seleccionada, o null si no se encontró ninguna.
     */
    private Shape figuraSeleccionada(Point2D p) {
        for (int i = vShape.size() - 1; i >= 0; i--) {
            Shape s = vShape.get(i);
            if (s.contains(p)) {
                figuraSeleccionada = s;
                marcadorSeleccion = new MarcadorSeleccion(((AbstractShape) s).getLocation());
                return s;
            }
        }
        figuraSeleccionada = null;
        marcadorSeleccion = null;
        return null;
    }

    public void updateFiguraSeleccionada() {
        if (figuraSeleccionada != null) {
            ((AbstractShape) figuraSeleccionada).setColor(color);
            ((AbstractShape) figuraSeleccionada).setGrosor(grosor);
            ((AbstractShape) figuraSeleccionada).setTransparenciaActiva(transparenciaActiva);
            ((AbstractShape) figuraSeleccionada).setAlisadoActivo(alisadoActivo);
            if (figuraSeleccionada instanceof AbstractShapeFilled) {
                ((AbstractShapeFilled) figuraSeleccionada).setRelleno(relleno);
            }
            this.repaint();
        }
    }

    public void volcarFiguraSeleccionada() {
        if (figuraSeleccionada != null) {
            Graphics2D g2d = img.createGraphics();
            ((AbstractShape) figuraSeleccionada).draw(g2d);
            g2d.dispose();
            vShape.remove(figuraSeleccionada);
            figuraSeleccionada = null;
            marcadorSeleccion = null;
            repaint();
        }
    }

    /**
     * Método que se ejecuta cuando se presiona el botón del mouse en el lienzo.
     *
     * @param evt El evento del mouse.
     */
    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        this.posicionPressed = evt.getPoint();

        if (edicion) {
            figura = figuraSeleccionada(evt.getPoint());
        } else {
            Shape figuraAux = null;
            switch (herramienta) {
                case LINEA:
                    figuraAux = new MiLinea(posicionPressed, posicionPressed);
                    break;
                case RECTANGULO:
                    figuraAux = new MiRectangulo(posicionPressed, posicionPressed);
                    break;
                case ELIPSE:
                    figuraAux = new MiElipse(posicionPressed, posicionPressed);
                    break;
                case FANTASMA:
                    figuraAux = new MiFantasma(posicionPressed);
                    break;
            }

            if (figuraAux != null) {
                ((AbstractShape) figuraAux).setColor(color);
                ((AbstractShape) figuraAux).setGrosor(grosor);
                ((AbstractShape) figuraAux).setTransparenciaActiva(transparenciaActiva);
                ((AbstractShape) figuraAux).setAlisadoActivo(alisadoActivo);
                if (figuraAux instanceof AbstractShapeFilled) {
                    ((AbstractShapeFilled) figuraAux).setRelleno(relleno);
                }
                this.figura = figuraAux;
                this.vShape.add(figura);
            }
        }
    }//GEN-LAST:event_formMousePressed

    /**
     * Método que se ejecuta cuando se arrastra el mouse en el lienzo.
     *
     * @param evt El evento del mouse.
     */
    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        this.posicionDragged = evt.getPoint();

        if (figura != null) {

            if (edicion) {
                if (figura instanceof MiLinea) {
                    ((MiLinea) figura).setLocation(posicionDragged);
                } else if (figura instanceof MiRectangulo) {
                    ((MiRectangulo) figura).setLocation(posicionDragged);
                } else if (figura instanceof MiElipse) {
                    ((MiElipse) figura).setLocation(posicionDragged);
                } else if (figura instanceof MiFantasma) {
                    ((MiFantasma) figura).setLocation(posicionDragged);
                }
                if (marcadorSeleccion != null) {
                    marcadorSeleccion.setLocation(((AbstractShape) figura).getLocation());
                }
            } else {

                switch (herramienta) {
                    case LINEA:
                        ((MiLinea) figura).setLine(posicionPressed, posicionDragged);
                        break;
                    case RECTANGULO:
                        ((MiRectangulo) figura).setFrameFromDiagonal(posicionPressed, posicionDragged);
                        break;
                    case ELIPSE:
                        ((MiElipse) figura).setFrameFromDiagonal(posicionPressed, posicionDragged);
                        break;
                }
            }
        }
        this.repaint();
    }//GEN-LAST:event_formMouseDragged

    /**
     * Método que se ejecuta cuando se suelta el botón del mouse en el lienzo.
     *
     * @param evt El evento del mouse.
     */
    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        this.figura = null;
        this.repaint();
    }//GEN-LAST:event_formMouseReleased

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
